defmodule Gettext.Merger do
  @moduledoc false

  alias Gettext.PO
  alias Gettext.PO.Translation
  alias Gettext.PO.PluralTranslation

  @doc """
  Merges a PO file with a POT file given their paths.

  This function returns the contents (as iodata) of the merged file, which will
  be written to a PO file.
  """
  @spec merge_files(Path.t, Path.t) :: iodata
  def merge_files(po_file, pot_file) do
    merge(PO.parse_file!(po_file), PO.parse_file!(pot_file)) |> PO.dump
  end

  @doc """
  Merges two `Gettext.PO` structs representing an PO file and an updated POT
  file.

  The following rules are observed:

    * headers from the PO file are kept
    * the `:file` field is taken from the PO file (as that's the file that will
      be updated)
    * translations in the PO file that do not have a match in the POT file are
      discarded, regardless of them being generated by gettext or manually
      entered by the user (remember, the POT file is the holy reference)
    * matching translations are merged as follows:
      * existing msgstr are preserved (the ones in the POT file are empty anyways)
      * existing translator comments are preserved (there are no translator
        comments in POT files)
      * existing references are discarded (as they're now outdated) and replaced
        by the references in the POT file

  """
  @spec merge(PO.t, PO.t) :: PO.t
  def merge(%PO{} = po, %PO{} = pot) do
    %PO{
      headers: po.headers,
      file: po.file,
      translations: merge_translations(po.translations, pot.translations),
    }
  end

  defp merge_translations(old, new) do
    merged = Enum.flat_map old, fn(t) ->
      if same = PO.Translations.find(new, t) do
        [merge_two_translations(t, same)]
      else
        [t]
      end
    end

    new = Enum.reject(new, &PO.Translations.find(old, &1))

    merged ++ new
  end

  defp merge_two_translations(%Translation{} = old, %Translation{} = new) do
    %Translation{
      msgid: new.msgid, # they are the same
      msgstr: old.msgstr, # new.msgstr should be empty since it's a POT file
      comments: old.comments, # new has no translator comments
      references: new.references,
    }
  end

  defp merge_two_translations(%PluralTranslation{} = old, %PluralTranslation{} = new) do
    %PluralTranslation{
      msgid: new.msgid, # they are the same
      msgid_plural: new.msgid_plural, # they are the same
      msgstr: old.msgstr, # new.msgstr should be empty since it's a POT file
      comments: old.comments, # new has no translator comments
      references: new.references,
    }
  end

  @doc """
  Returns the contents of a new PO file to be written at `po_file` from the POT
  template in `pot_file`.

  The new PO file will have:

    * the `Language` header set based on the locale (extracted from the path)
    * the translations of the POT file (no merging is needed as there are no
      translations in the PO file)

  """
  @spec new_po_file(Path.t, Path.t) :: iodata
  def new_po_file(po_file, pot_file) do
    pot = PO.parse_file!(pot_file)
    po = %PO{
      headers: headers_for_new_po_file(po_file),
      file: po_file,
      translations: pot.translations,
    }

    PO.dump(po)
  end

  defp headers_for_new_po_file(po_file) do
    [
      "Language: #{locale_from_path(po_file)}",
    ]
  end

  defp locale_from_path(path) do
    parts = Path.split(path)
    index = Enum.find_index(parts, &(&1 == "LC_MESSAGES"))
    Enum.at(parts, index - 1)
  end
end
